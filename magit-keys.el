(defvar magit-mode-map
  (let ((map (make-keymap)))
    (suppress-keymap map t)
    (define-key map (kbd "n") 'magit-goto-next-section)
    (define-key map (kbd "p") 'magit-goto-previous-section)
    (define-key map (kbd "TAB") 'magit-toggle-section)
    (define-key map (kbd "<backtab>") 'magit-expand-collapse-section)
    (define-key map (kbd "1") 'magit-show-level-1)
    (define-key map (kbd "2") 'magit-show-level-2)
    (define-key map (kbd "3") 'magit-show-level-3)
    (define-key map (kbd "4") 'magit-show-level-4)
    (define-key map (kbd "M-1") 'magit-show-level-1-all)
    (define-key map (kbd "M-2") 'magit-show-level-2-all)
    (define-key map (kbd "M-3") 'magit-show-level-3-all)
    (define-key map (kbd "M-4") 'magit-show-level-4-all)
    (define-key map (kbd "M-h") 'magit-show-only-files)
    (define-key map (kbd "M-H") 'magit-show-only-files-all)
    (define-key map (kbd "M-s") 'magit-show-level-4)
    (define-key map (kbd "M-S") 'magit-show-level-4-all)
    (define-key map (kbd "<M-left>") 'magit-goto-parent-section)
    (define-key map (kbd "g") 'magit-refresh)
    (define-key map (kbd "G") 'magit-refresh-all)
    (define-key map (kbd "?") 'magit-describe-item)
    (define-key map (kbd "!") 'magit-shell-command)
    (define-key map (kbd ":") 'magit-git-command)
    (define-key map (kbd "RET") 'magit-visit-item)
    (define-key map (kbd "SPC") 'magit-show-item-or-scroll-up)
    (define-key map (kbd "DEL") 'magit-show-item-or-scroll-down)
    (define-key map (kbd "C-w") 'magit-copy-item-as-kill)
    (define-key map (kbd "R") 'magit-rebase-step)
    (define-key map (kbd "r s") 'magit-rewrite-start)
    (define-key map (kbd "r t") 'magit-rewrite-stop)
    (define-key map (kbd "r a") 'magit-rewrite-abort)
    (define-key map (kbd "r f") 'magit-rewrite-finish)
    (define-key map (kbd "r *") 'magit-rewrite-set-unused)
    (define-key map (kbd "r .") 'magit-rewrite-set-used)
    (define-key map (kbd "P") 'magit-push)
    (define-key map (kbd "f") 'magit-remote-update)
    (define-key map (kbd "F") 'magit-pull)
    (define-key map (kbd "c") 'magit-log-edit)
    (define-key map (kbd "l") 'magit-log-menu)
    (define-key map (kbd "$") 'magit-display-process)
    (define-key map (kbd "E") 'magit-interactive-rebase)
    (define-key map (kbd "q") 'quit-window)
    map))

(defvar magit-commit-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "a") 'magit-apply-item)
    (define-key map (kbd "A") 'magit-cherry-pick-item)
    (define-key map (kbd "v") 'magit-revert-item)
    map))

(defvar magit-status-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "-") 'magit-diff-smaller-hunks)
    (define-key map (kbd "+") 'magit-diff-larger-hunks)
    (define-key map (kbd "0") 'magit-diff-default-hunks)
    (define-key map (kbd "s") 'magit-stage-item)
    (define-key map (kbd "S") 'magit-stage-all)
    (define-key map (kbd "u") 'magit-unstage-item)
    (define-key map (kbd "U") 'magit-unstage-all)
    (define-key map (kbd "i") 'magit-ignore-item)
    (define-key map (kbd "I") 'magit-ignore-item-locally)
    (define-key map (kbd ".") 'magit-mark-item)
    (define-key map (kbd "=") 'magit-diff-with-mark)
    (define-key map (kbd "d") 'magit-diff-working-tree)
    (define-key map (kbd "D") 'magit-diff)
    (define-key map (kbd "a") 'magit-apply-item)
    (define-key map (kbd "A") 'magit-cherry-pick-item)
    (define-key map (kbd "v") 'magit-revert-item)
    (define-key map (kbd "b") 'magit-branch-menu)
    (define-key map (kbd "m") 'magit-manual-merge)
    (define-key map (kbd "M") 'magit-automatic-merge)
    (define-key map (kbd "k") 'magit-discard-item)
    (define-key map (kbd "e") 'magit-interactive-resolve-item)
    (define-key map (kbd "C") 'magit-add-log)
    (define-key map (kbd "x") 'magit-reset-head)
    (define-key map (kbd "X") 'magit-reset-working-tree)
    (define-key map (kbd "t") 'magit-tag)
    (define-key map (kbd "T") 'magit-annotated-tag)
    (define-key map (kbd "z") 'magit-stash)
    (define-key map (kbd "Z") 'magit-stash-snapshot)
    map))

(defvar magit-stash-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "-") 'magit-diff-smaller-hunks)
    (define-key map (kbd "+") 'magit-diff-larger-hunks)
    (define-key map (kbd "0") 'magit-diff-default-hunks)
    (define-key map (kbd "a") 'magit-apply-item)
    (define-key map (kbd "A") 'magit-cherry-pick-item)
    (define-key map (kbd "v") 'magit-revert-item)
    map))

(defvar magit-log-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd ".") 'magit-mark-item)
    (define-key map (kbd "=") 'magit-diff-with-mark)
    (define-key map (kbd "d") 'magit-diff-working-tree)
    (define-key map (kbd "D") 'magit-diff)
    (define-key map (kbd "a") 'magit-apply-item)
    (define-key map (kbd "s") 'magit-log-grep)
    (define-key map (kbd "A") 'magit-cherry-pick-item)
    (define-key map (kbd "v") 'magit-revert-item)
    (define-key map (kbd "b") 'magit-branch-menu)
    (define-key map (kbd "m") 'magit-manual-merge)
    (define-key map (kbd "M") 'magit-automatic-merge)
    (define-key map (kbd "x") 'magit-reset-head)
    (define-key map (kbd "e") 'magit-log-show-more-entries)
    (define-key map (kbd "l") 'magit-log-menu)
    map))

(defvar magit-reflog-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd ".") 'magit-mark-item)
    (define-key map (kbd "=") 'magit-diff-with-mark)
    (define-key map (kbd "d") 'magit-diff-working-tree)
    (define-key map (kbd "D") 'magit-diff)
    (define-key map (kbd "a") 'magit-apply-item)
    (define-key map (kbd "A") 'magit-cherry-pick-item)
    (define-key map (kbd "v") 'magit-revert-item)
    (define-key map (kbd "x") 'magit-reset-head)
    map))

(defvar magit-diff-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "-") 'magit-diff-smaller-hunks)
    (define-key map (kbd "+") 'magit-diff-larger-hunks)
    (define-key map (kbd "0") 'magit-diff-default-hunks)
    (define-key map (kbd "a") 'magit-apply-item)
    (define-key map (kbd "A") 'magit-cherry-pick-item)
    (define-key map (kbd "v") 'magit-revert-item)
    map))

(defvar magit-wazzup-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd ".") 'magit-mark-item)
    (define-key map (kbd "=") 'magit-diff-with-mark)
    (define-key map (kbd "d") 'magit-diff-working-tree)
    (define-key map (kbd "D") 'magit-diff)
    (define-key map (kbd "a") 'magit-apply-item)
    (define-key map (kbd "A") 'magit-cherry-pick-item)
    (define-key map (kbd "v") 'magit-revert-item)
    (define-key map (kbd "b") 'magit-branch-menu)
    (define-key map (kbd "m") 'magit-manual-merge)
    (define-key map (kbd "M") 'magit-automatic-merge)
    (define-key map (kbd "x") 'magit-reset-head)
    (define-key map (kbd "i") 'magit-ignore-item)
    map))

(defvar magit-menu
  '((logging
     (?l "One line log" magit-log)
     (?L "Detailed log" magit-log-long)
     (?h "Reflog" magit-reflog)
     (?H "Reflog head" magit-reflog-head)
     (?a "--all" "All branches" magit-true)
     (?g "--grep=" "Containing regexp" read-from-minibuffer)
     (?A "--author=" "By author" read-from-minibuffer)
     (?C "--committer=" "By committer" read-from-minibuffer)
     (?F "--first-parent" "Follow only first parent" magit-true)
     (?B "--branches=" "Branches" read-from-minibuffer)
     (?R "--relative=" "Restrict to path" read-directory-name))
    (branching
     (?b "Switch" magit-checkout)
     (?B "Create" magit-create-branch)
     (?V "Show branches" magit-show-branches)
     (?k "Delete" magit-delete-branch)
     (?m "Move/Rename" magit-move-branch)
     (?w "Wazzup" magit-wazzup)
     (?T "--no-track" "Do not track remote parent branch" magit-true)
     (?R "-r" "Consider remote-tracking branches" magit-true)
     (?C "--contains" "Only branches that contain the given commit" magit-read-rev)
     (?M "--merged" "Only branches merged into the given commit" magit-read-rev)
     (?N "--no-merged" "Only branches not merged into the given commit" magit-read-rev))))

(defun magit-log-menu (&optional arg)
  (interactive "P")
  (magit-menu 'logging arg))

(defun magit-branch-menu (&optional arg)
  (interactive "P")
  (magit-menu 'branching arg))

(defvar magit-custom-options '()
  "This variable is for internal use by the magit menu
  functionality. Before executing a menu command, it is bound to
  the list of arguments corresponding to the options setted by
  the user on the menu.")

(magit-get-menu-options 'logging)

(defun magit-get-menu-options (group)
  (let ((menu-items '()))
    (dolist (item magit-menu)
      (when (string= (car item) group)
        (cond
         ((stringp (nth 3 item)) ;; It's an option
          ;; We append an extra cell to the item for storing the option's value:
          (setq menu-items (append menu-items (list (append item (list nil))))))
         ((functionp (nth 3 item)) ;; It's a command
          (setq menu-items (append menu-items (list item))))
         (t (error "Unrecognised item type in `magit-menu': %S." item)))))
    menu-items))

(defun magit-menu-insert-item (text highlight-p)
  (let* ((item-width 35)
         (max-items-perline 2)
         (max-columns (window-width))
         (begin)
         (current-column (- (point) (line-beginning-position)))
         (padding
          (make-string (- item-width (mod (length text) item-width)) 32)))
    (when (< max-columns (+ current-column (length text) (length padding)))
      (insert "\n"))
    (setq begin (point))
    (insert text)
    (when highlight-p
      (put-text-property begin (point) 'face 'magit-menu-selected-option))
    (insert padding)))

(defun magit-build-menu (group menu-items)
  (erase-buffer)
  (let ((s ""))
    (insert group " variants\n")
    (dolist (item menu-items)
      (when (functionp (nth 3 item))
        (setq s (concat (string (nth 1 item)) "  " (nth 2 item)))
        (magit-menu-insert-item s nil)))
    (insert "\nOptions\n")
    (dolist (item menu-items)
      (let ((args (magit-menu-make-arguments-for-option item t)))
        (when args
          (setq s (concat (string (nth 1 item)) "  " (nth 0 args)
                          " " (nth 1 args)))
          (magit-menu-insert-item s (nth 5 item)))))
    (insert "\n"))
    (setq buffer-read-only nil)
    (fit-window-to-buffer))

(defun magit-menu (group &optional prefix-arg)
  (let ((magit-buf (current-buffer))
        (menu-buf)
        (menu-items (magit-get-menu-options group))
        (prompt (concat (if prefix-arg (format "(prefix: %s) " prefix-arg))
                        "Command key (? for help): "))
        (display-help-p)
        (chosen-fn nil))
    (save-window-excursion
      (delete-other-windows)
      (switch-to-buffer-other-window "*Magit Commands*" t)
      (setq menu-buf (current-buffer))
      (catch 'exit
        (while t
          (pop-to-buffer menu-buf)
          (magit-build-menu group menu-items)
          (let ((c (read-char-exclusive prompt))
                (case-fold-search nil))
            (cond
             ;; Bail out if the input is not a character (Meta-x etc):
             ((not (characterp c))
              (throw 'exit 0))
             ((char-equal c ??)
              (setq display-help-p t)
              (setq prompt "Show help for command: "))
             (t
              (dolist (item menu-items)
                (when (char-equal c (nth 1 item))
                  ;; If a command, fn is a function.
                  ;; If an option, fn is a string.
                  (setq fn (nth 3 item))
                  (cond
                   ((and (stringp fn) display-help-p)
                    (message "No help for options!")
                    (sit-for 2))
                   ((and (stringp fn) (nth 5 item))
                    (setcar (nthcdr 5 item) nil))
                   ((stringp fn)
                    (setcar (nthcdr 5 item)
                            (funcall (nth 4 item) (concat (nth 2 item) ": "))))
                   (display-help-p
                    (setq chosen-fn fn)
                    (throw 'exit 0))
                   (t
                    (setq chosen-fn fn)
                    (throw 'exit 0))))))
             (error "Invalid key: %c" c))))))
    (when chosen-fn
      (if display-help-p
          (describe-function chosen-fn)
        (setq current-prefix-arg prefix-arg)
        (let ((magit-custom-options (magit-menu-make-option-list menu-items)))
          (call-interactively chosen-fn))))))

(defun magit-menu-make-arguments-for-option (item &optional all-p)
  "Returns as a cons cell the arguments for the git process
depending on the contents of `item'. If the option was not set,
returns nil, unless `all-p' evals to true."
  (let* ((option (nth 2 item))
         (value (nth 5 item))
         (join-valuep
          (and (stringp value)
               (string= "=" (substring option (- (length option) 1))))))
    (when (and (stringp (nth 3 item)) (or value all-p))
        (cons (concat option (when join-valuep value))
              (when (and (stringp value) (not join-valuep)) value)))))

(defun magit-menu-make-option-list (menu-items)
  (let ((result '()))
    (dolist (item menu-items)
      (setq result (append result (magit-menu-make-arguments-for-option item))))
    result))

(provide 'magit-keys)
